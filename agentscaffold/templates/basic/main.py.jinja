#!/usr/bin/env python
"""
Main entry point for the {{ agent_name }} agent.
"""

import os
import sys
import asyncio
import argparse
import json
import uuid
from typing import Dict, Any, Optional

# Import your agent
try:
    from {{ package_name }}.agent import {{ agent_class_name }}

except ImportError:
    print("Could not import {{ agent_class_name }}. Make sure the package is installed.")
    sys.exit(1)

# Load environment variables
try:
    from dotenv import load_dotenv
    load_dotenv()
    print("‚úÖ Loaded environment variables")
except ImportError:
    print("Warning: python-dotenv not installed. Using system environment variables only.")

async def main():
    """Run the agent with the given arguments."""
    parser = argparse.ArgumentParser(description="Run {{ agent_name }}")
    parser.add_argument("--message", "-m", help="Message to process")
    parser.add_argument("--interactive", "-i", action="store_true", help="Run in interactive mode")
    parser.add_argument("--search", "-s", help="Search query")
    parser.add_argument("--context", "-c", action="store_true", help="Retrieve context from memory")
    parser.add_argument("--context-query", help="Query for context retrieval")
    parser.add_argument("--silent", action="store_true", help="Run with minimal console output")
    parser.add_argument("--mcp-tool", help="MCP tool to use (e.g., brave-search, chroma-memory)")
    parser.add_argument("--mcp-query", help="Query for the MCP tool")
    parser.add_argument("--no-daytona", action="store_true", help="Skip Daytona runtime")
    
    args = parser.parse_args()
    
    # Generate persistent conversation ID
    conversation_id = os.environ.get("CONVERSATION_ID", str(uuid.uuid4()))
    
    # Initialize agent
    agent = {{ agent_class_name }}(conversation_id=conversation_id)
    if args.silent:
        agent.set_silent_mode(True)
    
    print("üîß Initializing {{ agent_name }} agent...")
    
    # Handle direct MCP tool execution
    if args.mcp_tool:
        print(f"üõ†Ô∏è Using MCP tool: {args.mcp_tool}")
        query = args.mcp_query or args.message or "test query"
        
        if hasattr(agent, "mcp_provider") and agent.mcp_provider:
            try:
                input_data = {"query": query}
                
                if args.message and args.message.lower().startswith("remember that"):
                    # Store memory
                    memory_content = args.message[13:].strip()
                    input_data = {
                        "operation": "store",
                        "data": {
                            "content": memory_content,
                            "timestamp": __import__("time").time(),
                            "conversation_id": conversation_id
                        }
                    }
                
                result = await agent.mcp_provider.execute(args.mcp_tool, input_data)
                print(json.dumps(result, indent=2))
                return
            except Exception as e:
                print(f"‚ùå Error using MCP: {e}")
                print("Falling back to standard execution")
    
    # Skip Daytona if specified
    if args.no_daytona and hasattr(agent, "runtime"):
        print("‚ö†Ô∏è Bypassing Daytona runtime, using local execution")
        agent.runtime = None
    
    # Process search query
    if args.search:
        print(f"üîç Searching for: {args.search}")
        result = await agent.run({
            "message": f"Search for {args.search}",
            "mcp_tool": "brave-search",
            "mcp_query": args.search
        })
        print(f"\nSearch results:\n\n{result.get('response', 'No results found')}")
        return
    
    # Process context query
    if args.context or args.context_query:
        query = args.context_query or ""
        print(f"üß† Retrieving context for: {query}")
        result = await agent.run({
            "message": f"Remember {query}",
            "mcp_tool": "chroma-memory",
            "mcp_query": query
        })
        print(f"\nContext:\n\n{result.get('response', 'No context found')}")
        return
    
    # Process message or run interactive mode
    if args.message:
        print(f"üìù Processing message: {args.message}")
        result = await agent.run({"message": args.message})
        print(f"\nAgent: {result.get('response', 'No response')}")
    elif args.interactive:
        print(f"\nüöÄ {agent.name} - {agent.description}")
        print("Type 'quit' or 'exit' to end session")
        
        while True:
            try:
                user_input = input("\nYou: ")
                if user_input.lower() in ["quit", "exit", "bye"]:
                    print("üëã Goodbye!")
                    break
                
                print("‚ö° Processing...")
                result = await agent.run({"message": user_input})
                print(f"\nAgent: {result.get('response', 'No response')}")
            except KeyboardInterrupt:
                print("\nüëã Session interrupted. Goodbye!")
                break
    else:
        parser.print_help()

if __name__ == "__main__":
    asyncio.run(main())